<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js OBJLoader + WebGL2</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
        }
        
        #container {
            display: flex;
            gap: 20px;
            height: calc(100vh - 40px);
        }
        
        #controls {
            width: 300px;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 10px;
            overflow-y: auto;
        }
        
        #canvas-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #333;
            border-radius: 10px;
        }
        
        canvas {
            border: 2px solid #555;
            border-radius: 8px;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        input[type="file"] {
            width: 100%;
            padding: 10px;
            background: #444;
            border: 1px solid #666;
            border-radius: 5px;
            color: white;
        }
        
        button {
            width: 100%;
            padding: 12px;
            background: #4CAF50;
            border: none;
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .slider-group {
            margin: 15px 0;
        }
        
        .slider-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        .info {
            background: #333;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .error {
            color: #ff6b6b;
            background: #2d1b1b;
            border: 1px solid #ff6b6b;
        }
        
        .success {
            color: #4CAF50;
            background: #1b2d1b;
            border: 1px solid #4CAF50;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="controls">
            <h2>OBJæ¨¡å‹åŠ è½½å™¨</h2>
            
            <div class="control-group">
                <h3>ğŸ“ åŠ è½½æ¨¡å‹</h3>
                <input type="file" id="objFile" accept=".obj" />
                <button id="loadDefault">åŠ è½½é»˜è®¤ç«‹æ–¹ä½“</button>
            </div>
            
            <div class="control-group">
                <h3>ğŸ® æ§åˆ¶</h3>
                <div class="slider-group">
                    <label>æ—‹è½¬ X: <span id="rotXValue">0</span>Â°</label>
                    <input type="range" id="rotX" min="-180" max="180" value="0" step="1">
                </div>
                <div class="slider-group">
                    <label>æ—‹è½¬ Y: <span id="rotYValue">0</span>Â°</label>
                    <input type="range" id="rotY" min="-180" max="180" value="0" step="1">
                </div>
                <div class="slider-group">
                    <label>æ—‹è½¬ Z: <span id="rotZValue">0</span>Â°</label>
                    <input type="range" id="rotZ" min="-180" max="180" value="0" step="1">
                </div>
                <div class="slider-group">
                    <label>ç¼©æ”¾: <span id="scaleValue">1.0</span></label>
                    <input type="range" id="scale" min="0.1" max="3" value="1" step="0.1">
                </div>
            </div>
            
            <div class="control-group">
                <h3>ğŸ¨ æ¸²æŸ“</h3>
                <button id="wireframe">åˆ‡æ¢çº¿æ¡†æ¨¡å¼</button>
                <button id="resetView">é‡ç½®è§†è§’</button>
            </div>
            
            <div id="info" class="info">
                <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong><br>
                1. é€‰æ‹©OBJæ–‡ä»¶æˆ–ç‚¹å‡»åŠ è½½é»˜è®¤æ¨¡å‹<br>
                2. ä½¿ç”¨æ»‘å—è°ƒæ•´æ¨¡å‹å§¿æ€<br>
                3. æ”¯æŒçº¿æ¡†æ¨¡å¼åˆ‡æ¢<br><br>
                <strong>æŠ€æœ¯å®ç°ï¼š</strong><br>
                â€¢ Three.js OBJLoaderè§£ææ¨¡å‹<br>
                â€¢ æå–é¡¶ç‚¹ã€æ³•çº¿æ•°æ®<br>
                â€¢ åŸç”ŸWebGL2æ¸²æŸ“ç®¡çº¿<br>
                â€¢ è‡ªå®šä¹‰ç€è‰²å™¨ç¨‹åº
            </div>
        </div>
        
        <div id="canvas-container">
            <canvas id="webglCanvas" width="800" height="600"></canvas>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script>
        class WebGL2Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.gl = canvas.getContext('webgl2');
                if (!this.gl) {
                    throw new Error('WebGL2 not supported');
                }
                
                this.program = null;
                this.vertexBuffer = null;
                this.normalBuffer = null;
                this.indexBuffer = null;
                this.vertexCount = 0;
                this.indexCount = 0;
                this.isWireframe = false;
                
                this.setupShaders();
                this.setupMatrices();
                
                // å¯ç”¨æ·±åº¦æµ‹è¯•
                this.gl.enable(this.gl.DEPTH_TEST);
                this.gl.clearColor(0.1, 0.1, 0.1, 1.0);
            }
            
            setupShaders() {
                const vertexShaderSource = `#version 300 es
                    precision highp float;
                    
                    in vec3 aPosition;
                    in vec3 aNormal;
                    
                    uniform mat4 uModelViewMatrix;
                    uniform mat4 uProjectionMatrix;
                    uniform mat3 uNormalMatrix;
                    
                    out vec3 vNormal;
                    out vec3 vPosition;
                    
                    void main() {
                        vec4 mvPosition = uModelViewMatrix * vec4(aPosition, 1.0);
                        gl_Position = uProjectionMatrix * mvPosition;
                        
                        vNormal = normalize(uNormalMatrix * aNormal);
                        vPosition = mvPosition.xyz;
                    }
                `;
                
                const fragmentShaderSource = `#version 300 es
                    precision highp float;
                    
                    in vec3 vNormal;
                    in vec3 vPosition;
                    
                    uniform bool uWireframe;
                    
                    out vec4 fragColor;
                    
                    void main() {
                        if (uWireframe) {
                            fragColor = vec4(0.0, 1.0, 0.5, 1.0);
                        } else {
                            vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));
                            vec3 normal = normalize(vNormal);
                            
                            float diffuse = max(dot(normal, lightDir), 0.0);
                            vec3 color = vec3(0.3, 0.6, 1.0) * (0.3 + 0.7 * diffuse);
                            
                            fragColor = vec4(color, 1.0);
                        }
                    }
                `;
                
                const vertexShader = this.createShader(this.gl.VERTEX_SHADER, vertexShaderSource);
                const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, fragmentShaderSource);
                
                this.program = this.createProgram(vertexShader, fragmentShader);
                this.gl.useProgram(this.program);
                
                // è·å–attributeå’Œuniformä½ç½®
                this.locations = {
                    aPosition: this.gl.getAttribLocation(this.program, 'aPosition'),
                    aNormal: this.gl.getAttribLocation(this.program, 'aNormal'),
                    uModelViewMatrix: this.gl.getUniformLocation(this.program, 'uModelViewMatrix'),
                    uProjectionMatrix: this.gl.getUniformLocation(this.program, 'uProjectionMatrix'),
                    uNormalMatrix: this.gl.getUniformLocation(this.program, 'uNormalMatrix'),
                    uWireframe: this.gl.getUniformLocation(this.program, 'uWireframe')
                };
            }
            
            createShader(type, source) {
                const shader = this.gl.createShader(type);
                this.gl.shaderSource(shader, source);
                this.gl.compileShader(shader);
                
                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
                    console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
                    this.gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }
            
            createProgram(vertexShader, fragmentShader) {
                const program = this.gl.createProgram();
                this.gl.attachShader(program, vertexShader);
                this.gl.attachShader(program, fragmentShader);
                this.gl.linkProgram(program);
                
                if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
                    console.error('Program linking error:', this.gl.getProgramInfoLog(program));
                    this.gl.deleteProgram(program);
                    return null;
                }
                return program;
            }
            
            setupMatrices() {
                // æŠ•å½±çŸ©é˜µ (é€è§†æŠ•å½±)
                this.projectionMatrix = this.createPerspectiveMatrix(
                    45 * Math.PI / 180, // fov
                    this.canvas.width / this.canvas.height, // aspect
                    0.1, // near
                    100.0 // far
                );
                
                // æ¨¡å‹è§†å›¾çŸ©é˜µåˆå§‹å€¼
                this.modelViewMatrix = this.createIdentityMatrix();
                this.normalMatrix = this.createIdentityMatrix();
                
                // è®¾ç½®ç›¸æœºä½ç½®
                this.translate(this.modelViewMatrix, 0, 0, -5);
            }
            
            loadModelData(geometries) {
                // æ”¯æŒå•ä¸ªå‡ ä½•ä½“æˆ–å‡ ä½•ä½“æ•°ç»„
                if (!Array.isArray(geometries)) {
                    geometries = [geometries];
                }
                
                // åˆå¹¶æ‰€æœ‰å‡ ä½•ä½“æ•°æ®
                const allPositions = [];
                const allNormals = [];
                const allIndices = [];
                let vertexOffset = 0;
                let totalVertices = 0;
                
                for (const geometry of geometries) {
                    const positions = geometry.attributes.position.array;
                    const normals = geometry.attributes.normal.array;
                    
                    // æ·»åŠ é¡¶ç‚¹å’Œæ³•çº¿
                    allPositions.push(...positions);
                    allNormals.push(...normals);
                    
                    // å¤„ç†ç´¢å¼•
                    if (geometry.index) {
                        const indices = geometry.index.array;
                        for (let i = 0; i < indices.length; i++) {
                            allIndices.push(indices[i] + vertexOffset);
                        }
                    } else {
                        // å¦‚æœæ²¡æœ‰ç´¢å¼•ï¼Œåˆ›å»ºé¡ºåºç´¢å¼•
                        const vertexCount = positions.length / 3;
                        for (let i = 0; i < vertexCount; i++) {
                            allIndices.push(vertexOffset + i);
                        }
                    }
                    
                    vertexOffset += positions.length / 3;
                    totalVertices += positions.length / 3;
                }
                
                // åˆ›å»ºåˆå¹¶åçš„ç¼“å†²åŒº
                this.vertexBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(allPositions), this.gl.STATIC_DRAW);
                
                this.normalBuffer = this.gl.createBuffer();
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
                this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(allNormals), this.gl.STATIC_DRAW);
                
                if (allIndices.length > 0) {
                    this.indexBuffer = this.gl.createBuffer();
                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(allIndices), this.gl.STATIC_DRAW);
                    this.indexCount = allIndices.length;
                } else {
                    this.vertexCount = totalVertices;
                }
                
                this.showMessage(`æ¨¡å‹æ•°æ®åŠ è½½æˆåŠŸï¼æ€»é¡¶ç‚¹æ•°: ${totalVertices}, å‡ ä½•ä½“æ•°é‡: ${geometries.length}`, 'success');
            }
            
            render(rotX = 0, rotY = 0, rotZ = 0, scale = 1) {
                this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
                
                if (!this.vertexBuffer) return;
                
                // é‡ç½®æ¨¡å‹è§†å›¾çŸ©é˜µ
                this.modelViewMatrix = this.createIdentityMatrix();
                this.translate(this.modelViewMatrix, 0, 0, -5);
                
                // åº”ç”¨å˜æ¢
                this.rotateX(this.modelViewMatrix, rotX * Math.PI / 180);
                this.rotateY(this.modelViewMatrix, rotY * Math.PI / 180);
                this.rotateZ(this.modelViewMatrix, rotZ * Math.PI / 180);
                this.scaleMatrix(this.modelViewMatrix, scale, scale, scale);
                
                // è®¡ç®—æ³•çº¿çŸ©é˜µ
                this.normalMatrix = this.createNormalMatrix(this.modelViewMatrix);
                
                // ä½¿ç”¨ç€è‰²å™¨ç¨‹åº
                this.gl.useProgram(this.program);
                
                // è®¾ç½®çŸ©é˜µuniform
                this.gl.uniformMatrix4fv(this.locations.uProjectionMatrix, false, this.projectionMatrix);
                this.gl.uniformMatrix4fv(this.locations.uModelViewMatrix, false, this.modelViewMatrix);
                this.gl.uniformMatrix3fv(this.locations.uNormalMatrix, false, this.normalMatrix);
                this.gl.uniform1i(this.locations.uWireframe, this.isWireframe);
                
                // ç»‘å®šé¡¶ç‚¹æ•°æ®
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vertexBuffer);
                this.gl.enableVertexAttribArray(this.locations.aPosition);
                this.gl.vertexAttribPointer(this.locations.aPosition, 3, this.gl.FLOAT, false, 0, 0);
                
                // ç»‘å®šæ³•çº¿æ•°æ®
                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.normalBuffer);
                this.gl.enableVertexAttribArray(this.locations.aNormal);
                this.gl.vertexAttribPointer(this.locations.aNormal, 3, this.gl.FLOAT, false, 0, 0);
                
                // æ¸²æŸ“
                if (this.indexBuffer) {
                    this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                    if (this.isWireframe) {
                        // çº¿æ¡†æ¨¡å¼ï¼šå°†ä¸‰è§’å½¢è½¬æ¢ä¸ºçº¿æ®µ
                        for (let i = 0; i < this.indexCount; i += 3) {
                            this.gl.drawElements(this.gl.LINE_LOOP, 3, this.gl.UNSIGNED_INT, i * 4);
                        }
                    } else {
                        this.gl.drawElements(this.gl.TRIANGLES, this.indexCount, this.gl.UNSIGNED_INT, 0);
                    }
                } else {
                    if (this.isWireframe) {
                        // çº¿æ¡†æ¨¡å¼
                        for (let i = 0; i < this.vertexCount; i += 3) {
                            this.gl.drawArrays(this.gl.LINE_LOOP, i, 3);
                        }
                    } else {
                        this.gl.drawArrays(this.gl.TRIANGLES, 0, this.vertexCount);
                    }
                }
            }
            
            toggleWireframe() {
                this.isWireframe = !this.isWireframe;
            }
            
            // çŸ©é˜µå·¥å…·å‡½æ•°
            createIdentityMatrix() {
                return new Float32Array([
                    1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
            }
            
            createPerspectiveMatrix(fov, aspect, near, far) {
                const f = Math.tan(Math.PI * 0.5 - 0.5 * fov);
                const rangeInv = 1.0 / (near - far);
                
                return new Float32Array([
                    f / aspect, 0, 0, 0,
                    0, f, 0, 0,
                    0, 0, (near + far) * rangeInv, -1,
                    0, 0, near * far * rangeInv * 2, 0
                ]);
            }
            
            translate(matrix, x, y, z) {
                matrix[12] += x;
                matrix[13] += y;
                matrix[14] += z;
            }
            
            rotateX(matrix, angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const rotMatrix = new Float32Array([
                    1, 0, 0, 0,
                    0, c, s, 0,
                    0, -s, c, 0,
                    0, 0, 0, 1
                ]);
                this.multiplyMatrices(matrix, rotMatrix, matrix);
            }
            
            rotateY(matrix, angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const rotMatrix = new Float32Array([
                    c, 0, -s, 0,
                    0, 1, 0, 0,
                    s, 0, c, 0,
                    0, 0, 0, 1
                ]);
                this.multiplyMatrices(matrix, rotMatrix, matrix);
            }
            
            rotateZ(matrix, angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const rotMatrix = new Float32Array([
                    c, s, 0, 0,
                    -s, c, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1
                ]);
                this.multiplyMatrices(matrix, rotMatrix, matrix);
            }
            
            scaleMatrix(matrix, x, y, z) {
                matrix[0] *= x;
                matrix[1] *= x;
                matrix[2] *= x;
                matrix[3] *= x;
                matrix[4] *= y;
                matrix[5] *= y;
                matrix[6] *= y;
                matrix[7] *= y;
                matrix[8] *= z;
                matrix[9] *= z;
                matrix[10] *= z;
                matrix[11] *= z;
            }
            
            multiplyMatrices(a, b, out) {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                
                const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
                const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
                const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
                const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];
                
                out[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30;
                out[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31;
                out[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32;
                out[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33;
                
                out[4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30;
                out[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31;
                out[6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32;
                out[7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33;
                
                out[8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30;
                out[9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31;
                out[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32;
                out[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33;
                
                out[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30;
                out[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31;
                out[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32;
                out[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33;
            }
            
            createNormalMatrix(modelViewMatrix) {
                // æå–3x3çŸ©é˜µå¹¶æ±‚é€†è½¬ç½®
                const normalMatrix = new Float32Array(9);
                normalMatrix[0] = modelViewMatrix[0];
                normalMatrix[1] = modelViewMatrix[1];
                normalMatrix[2] = modelViewMatrix[2];
                normalMatrix[3] = modelViewMatrix[4];
                normalMatrix[4] = modelViewMatrix[5];
                normalMatrix[5] = modelViewMatrix[6];
                normalMatrix[6] = modelViewMatrix[8];
                normalMatrix[7] = modelViewMatrix[9];
                normalMatrix[8] = modelViewMatrix[10];
                return normalMatrix;
            }
            
            showMessage(text, type = 'info') {
                const info = document.getElementById('info');
                info.className = `info ${type}`;
                info.innerHTML = text;
                if (type !== 'info') {
                    setTimeout(() => {
                        info.className = 'info';
                        info.innerHTML = `
                            <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong><br>
                            1. é€‰æ‹©OBJæ–‡ä»¶æˆ–ç‚¹å‡»åŠ è½½é»˜è®¤æ¨¡å‹<br>
                            2. ä½¿ç”¨æ»‘å—è°ƒæ•´æ¨¡å‹å§¿æ€<br>
                            3. æ”¯æŒçº¿æ¡†æ¨¡å¼åˆ‡æ¢<br><br>
                            <strong>æŠ€æœ¯å®ç°ï¼š</strong><br>
                            â€¢ Three.js OBJLoaderè§£ææ¨¡å‹<br>
                            â€¢ æå–é¡¶ç‚¹ã€æ³•çº¿æ•°æ®<br>
                            â€¢ åŸç”ŸWebGL2æ¸²æŸ“ç®¡çº¿<br>
                            â€¢ è‡ªå®šä¹‰ç€è‰²å™¨ç¨‹åº
                        `;
                    }, 3000);
                }
            }
        }
        
        // ç®€å•çš„OBJè§£æå™¨ï¼ˆä½œä¸ºå¤‡é€‰æ–¹æ¡ˆï¼‰
        class SimpleOBJLoader {
            parse(objText) {
                const vertices = [];
                const normals = [];
                const faces = [];
                
                const lines = objText.split('\n');
                
                for (let line of lines) {
                    line = line.trim();
                    if (line.startsWith('v ')) {
                        // é¡¶ç‚¹
                        const parts = line.split(/\s+/);
                        vertices.push([
                            parseFloat(parts[1]),
                            parseFloat(parts[2]),
                            parseFloat(parts[3])
                        ]);
                    } else if (line.startsWith('vn ')) {
                        // æ³•çº¿
                        const parts = line.split(/\s+/);
                        normals.push([
                            parseFloat(parts[1]),
                            parseFloat(parts[2]),
                            parseFloat(parts[3])
                        ]);
                    } else if (line.startsWith('f ')) {
                        // é¢
                        const parts = line.split(/\s+/).slice(1);
                        const face = parts.map(part => {
                            const indices = part.split('/');
                            return {
                                vertex: parseInt(indices[0]) - 1,
                                normal: indices[2] ? parseInt(indices[2]) - 1 : -1
                            };
                        });
                        faces.push(face);
                    }
                }
                
                // æ„å»ºThree.jså‡ ä½•ä½“
                const geometry = new THREE.BufferGeometry();
                
                const positions = [];
                const calculatedNormals = [];
                
                for (let face of faces) {
                    if (face.length >= 3) {
                        // ä¸‰è§’åŒ–ï¼ˆç®€å•å¤„ç†ï¼Œå‡è®¾éƒ½æ˜¯ä¸‰è§’å½¢æˆ–å››è¾¹å½¢ï¼‰
                        for (let i = 1; i < face.length - 1; i++) {
                            const indices = [0, i, i + 1];
                            
                            for (let idx of indices) {
                                const vertexIndex = face[idx].vertex;
                                const normalIndex = face[idx].normal;
                                
                                if (vertexIndex < vertices.length) {
                                    positions.push(...vertices[vertexIndex]);
                                    
                                    if (normalIndex >= 0 && normalIndex < normals.length) {
                                        calculatedNormals.push(...normals[normalIndex]);
                                    } else {
                                        calculatedNormals.push(0, 0, 1); // é»˜è®¤æ³•çº¿
                                    }
                                }
                            }
                        }
                    }
                }
                
                geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geometry.setAttribute('normal', new THREE.Float32BufferAttribute(calculatedNormals, 3));
                
                // å¦‚æœæ²¡æœ‰æ³•çº¿ï¼Œè®¡ç®—å®ƒä»¬
                if (calculatedNormals.every(n => n === 0 || n === 1)) {
                    geometry.computeVertexNormals();
                }
                
                const object = new THREE.Object3D();
                const mesh = new THREE.Mesh(geometry);
                object.add(mesh);
                
                return object;
            }
        }
        
        // åº”ç”¨ä¸»é€»è¾‘
        class App {
            constructor() {
                this.canvas = document.getElementById('webglCanvas');
                this.renderer = new WebGL2Renderer(this.canvas);
                
                // æ£€æŸ¥OBJLoaderæ˜¯å¦å¯ç”¨
                if (typeof THREE.OBJLoader !== 'undefined') {
                    this.objLoader = new THREE.OBJLoader();
                } else {
                    console.warn('Using fallback OBJ loader');
                    this.objLoader = new SimpleOBJLoader();
                }
                
                this.rotX = 0;
                this.rotY = 0;
                this.rotZ = 0;
                this.scale = 1;
                
                this.setupEventListeners();
                this.animate();
            }
            
            setupEventListeners() {
                // æ–‡ä»¶è¾“å…¥
                document.getElementById('objFile').addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        this.loadObjFile(e.target.files[0]);
                    }
                });
                
                // é»˜è®¤æ¨¡å‹
                document.getElementById('loadDefault').addEventListener('click', () => {
                    this.loadDefaultCube();
                });
                
                // æ—‹è½¬æ§åˆ¶
                document.getElementById('rotX').addEventListener('input', (e) => {
                    this.rotX = parseFloat(e.target.value);
                    document.getElementById('rotXValue').textContent = e.target.value;
                });
                
                document.getElementById('rotY').addEventListener('input', (e) => {
                    this.rotY = parseFloat(e.target.value);
                    document.getElementById('rotYValue').textContent = e.target.value;
                });
                
                document.getElementById('rotZ').addEventListener('input', (e) => {
                    this.rotZ = parseFloat(e.target.value);
                    document.getElementById('rotZValue').textContent = e.target.value;
                });
                
                // ç¼©æ”¾æ§åˆ¶
                document.getElementById('scale').addEventListener('input', (e) => {
                    this.scale = parseFloat(e.target.value);
                    document.getElementById('scaleValue').textContent = e.target.value;
                });
                
                // çº¿æ¡†æ¨¡å¼
                document.getElementById('wireframe').addEventListener('click', () => {
                    this.renderer.toggleWireframe();
                });
                
                // é‡ç½®è§†è§’
                document.getElementById('resetView').addEventListener('click', () => {
                    this.resetControls();
                });
            }
            
            loadObjFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const objText = e.target.result;
                        const object = this.objLoader.parse(objText);
                        
                        // æ”¶é›†æ‰€æœ‰meshçš„å‡ ä½•ä½“
                        const geometries = [];
                        let meshCount = 0;
                        
                        object.traverse((child) => {
                            if (child.isMesh) {
                                meshCount++;
                                const geometry = child.geometry;
                                
                                // ç¡®ä¿æœ‰æ³•çº¿
                                if (!geometry.attributes.normal) {
                                    geometry.computeVertexNormals();
                                }
                                
                                // åº”ç”¨meshçš„å˜æ¢åˆ°å‡ ä½•ä½“
                                geometry.applyMatrix4(child.matrix);
                                
                                geometries.push(geometry);
                            }
                        });
                        
                        if (geometries.length > 0) {
                            this.renderer.loadModelData(geometries);
                            this.renderer.showMessage(
                                `OBJæ¨¡å‹å®Œæ•´åŠ è½½æˆåŠŸï¼<br>
                                å‘ç° ${meshCount} ä¸ªMesh<br>
                                æ€»é¡¶ç‚¹æ•°: ${geometries.reduce((sum, g) => sum + g.attributes.position.count, 0)}`, 
                                'success'
                            );
                        } else {
                            this.renderer.showMessage('OBJæ–‡ä»¶ä¸­æœªæ‰¾åˆ°ä»»ä½•æœ‰æ•ˆçš„å‡ ä½•ä½“', 'error');
                        }
                    } catch (error) {
                        console.error('Error loading OBJ:', error);
                        this.renderer.showMessage('OBJæ–‡ä»¶è§£æå¤±è´¥: ' + error.message, 'error');
                    }
                };
                reader.readAsText(file);
            }
            
            loadDefaultCube() {
                // åˆ›å»ºä¸€ä¸ªåŒ…å«å¤šä¸ªå‡ ä½•ä½“çš„æµ‹è¯•åœºæ™¯
                const geometries = [];
                
                // ä¸»ç«‹æ–¹ä½“
                const mainCube = new THREE.BoxGeometry(2, 2, 2);
                mainCube.computeVertexNormals();
                geometries.push(mainCube);
                
                // å°ç«‹æ–¹ä½“1
                const smallCube1 = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                smallCube1.translate(3, 0, 0);
                smallCube1.computeVertexNormals();
                geometries.push(smallCube1);
                
                // å°ç«‹æ–¹ä½“2
                const smallCube2 = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                smallCube2.translate(-3, 0, 0);
                smallCube2.computeVertexNormals();
                geometries.push(smallCube2);
                
                // çƒä½“
                const sphere = new THREE.SphereGeometry(0.8, 16, 16);
                sphere.translate(0, 3, 0);
                sphere.computeVertexNormals();
                geometries.push(sphere);
                
                this.renderer.loadModelData(geometries);
            }
            
            resetControls() {
                this.rotX = 0;
                this.rotY = 0;
                this.rotZ = 0;
                this.scale = 1;
                
                document.getElementById('rotX').value = 0;
                document.getElementById('rotY').value = 0;
                document.getElementById('rotZ').value = 0;
                document.getElementById('scale').value = 1;
                
                document.getElementById('rotXValue').textContent = '0';
                document.getElementById('rotYValue').textContent = '0';
                document.getElementById('rotZValue').textContent = '0';
                document.getElementById('scaleValue').textContent = '1.0';
            }
            
            animate() {
                this.renderer.render(this.rotX, this.rotY, this.rotZ, this.scale);
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // å¯åŠ¨åº”ç”¨
        window.addEventListener('load', () => {
            try {
                new App();
            } catch (error) {
                document.getElementById('info').innerHTML = `
                    <div class="error">
                        <strong>é”™è¯¯:</strong> ${error.message}<br>
                        è¯·ç¡®ä¿æµè§ˆå™¨æ”¯æŒWebGL2
                    </div>
                `;
            }
        });
    </script>
</body>
</html>